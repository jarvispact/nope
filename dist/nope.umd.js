(function(n,d){typeof exports=="object"&&typeof module!="undefined"?d(exports):typeof define=="function"&&define.amd?define(["exports"],d):(n=typeof globalThis!="undefined"?globalThis:n||self,d(n.io={}))})(this,function(n){"use strict";const d=e=>({status:"SUCCESS",value:e}),l=e=>({status:"FAILURE",value:e}),A=e=>e.status==="SUCCESS",S=e=>e.status==="FAILURE",N=e=>e.value,T=(e,{onSuccess:r,onFailure:u})=>A(e)?r(e.value):u(e.value),s=(e,r,u,v)=>({schema:e,code:r,message:u,details:v}),E=e=>Object.keys(e),h=e=>typeof e=="object"&&!Array.isArray(e)&&e!==null,f=e=>e===null?"null":e instanceof Date?"date":h(e)?"record":Array.isArray(e)?"array":typeof e,g=e=>e.schema==="literal",p=e=>e.schema==="record",O="array",I=e=>s(O,"E_NOT_A_ARRAY","provided value is not of type array",{provided:{type:f(e),value:e},expected:{type:"array"}}),j=(e,r)=>{if(Array.isArray(r)&&r.length<1)throw new Error("empty constraints array is not allowed. provide at least 1 constraint or omit the empty array from the call to number()");return{schema:O,I:null,O:null,E:null,validate:o=>{if(!Array.isArray(o))return l({errors:[I(o)],items:[]});const a=(r||[]).map(i=>{if(!i.when(o))return;const{code:X,message:Z,details:x}=i.error(o);return s(O,X,Z,x)}).filter(Boolean),m=o.map(i=>e.validate(i)),c=m.some(i=>i.status==="FAILURE");return a.length||c?l({errors:a,items:m}):d(o)}}},w=({when:e,error:r})=>({when:e,error:r}),C=e=>s("boolean","E_NOT_A_BOOLEAN","provided value is not of type boolean",{provided:{type:f(e),value:e},expected:{type:"boolean"}}),R=()=>({schema:"boolean",I:null,O:null,E:null,validate:y=>typeof y=="boolean"?d(y):l(C(y))}),D=e=>s("date","E_NOT_A_DATE","provided value is not of type date",{provided:{type:f(e),value:e},expected:{type:"date"}}),L=e=>s("date","E_INVALID_DATE","provided date is invalid",{provided:{type:f(e),value:e},expected:{type:"date"}}),U=e=>{if(Array.isArray(e)&&e.length<1)throw new Error("empty constraints array is not allowed. provide at least 1 constraint or omit the empty array from the call to date()");return{schema:"date",I:null,O:null,E:null,validate:t=>{if(!(t instanceof Date))return l([D(t)]);if(t.toString()==="Invalid Date")return l([L(t)]);const o=(e||[]).map(a=>{if(!a.when(t))return;const{code:m,message:c,details:i}=a.error(t);return s("date",m,c,i)}).filter(Boolean);return o.length?l(o):d(t)}}},k=({when:e,error:r})=>({when:e,error:r}),B=(e,r)=>s("literal","E_INVALID_LITERAL",`the provided value does not match the specified literal: "${e}"`,{provided:{type:f(r),value:r},expected:{type:`${typeof e}-literal`,literal:e}}),F=e=>({schema:"literal",literal:e,I:null,O:null,E:null,validate:o=>o===e?d(o):l(B(e,o))}),K=e=>({schema:"nullable",I:null,O:null,E:null,validate:t=>t===null?d(null):e.validate(t)}),M=e=>s("number","E_NOT_A_NUMBER","provided value is not of type number",{provided:{type:f(e),value:e},expected:{type:"number"}}),Y=e=>{if(Array.isArray(e)&&e.length<1)throw new Error("empty constraints array is not allowed. provide at least 1 constraint or omit the empty array from the call to number()");return{schema:"number",I:null,O:null,E:null,validate:t=>{if(typeof t!="number")return l([M(t)]);const o=(e||[]).map(a=>{if(!a.when(t))return;const{code:m,message:c,details:i}=a.error(t);return s("number",m,c,i)}).filter(Boolean);return o.length?l(o):d(t)}}},$=({when:e,error:r})=>({when:e,error:r}),G=e=>({schema:"optional",I:null,O:null,E:null,validate:t=>t===void 0?d(void 0):e.validate(t)}),b=(e,r)=>s("record","E_NOT_A_RECORD","provided value is not of type record",{provided:{type:f(r),value:r},expected:{type:"record",keys:Object.keys(e)}}),H=(e,r)=>s("record","E_MISSING_KEYS","provided value has missing keys",{provided:{type:f(r),value:r},expected:{type:"record",keys:Object.keys(e)}}),V=(e,r)=>s("record","E_TOO_MANY_KEYS","provided value has too many keys",{provided:{type:f(r),value:r,keys:Object.keys(r)},expected:{type:"record",keys:Object.keys(e)}}),_=e=>({schema:"record",I:null,O:null,E:null,validate:t=>{if(!h(t))return l({errors:[b(e,t)],properties:{}});const o=[];E(e).length>E(t).length&&o.push(H(e,t)),E(t).length>E(e).length&&o.push(V(e,t));const a=E(e).reduce((c,i)=>(c[i]=e[i].validate(t[i]),c),{}),m=E(a).some(c=>a[c].status==="FAILURE");return o.length||m?l({errors:o,properties:a}):d(t)},definition:e}),z=e=>({schema:"partial",I:null,O:null,E:null,validate:t=>{if(!h(t))return l({errors:[b(e.definition,t)],properties:{}});const o=Object.fromEntries(Object.entries(e.definition).filter(([a])=>E(t).includes(a)));return _(o).validate(t)}}),J=e=>s("string","E_NOT_A_STRING","provided value is not of type string",{provided:{type:f(e),value:e},expected:{type:"string"}}),P=e=>{if(Array.isArray(e)&&e.length<1)throw new Error("empty constraints array is not allowed. provide at least 1 constraint or omit the empty array from the call to string()");return{schema:"string",I:null,O:null,E:null,validate:t=>{if(typeof t!="string")return l([J(t)]);const o=(e||[]).map(a=>{if(!a.when(t))return;const{code:m,message:c,details:i}=a.error(t);return s("string",m,c,i)}).filter(Boolean);return o.length?l(o):d(t)}}},q=({when:e,error:r})=>({when:e,error:r}),Q=(e,r)=>s("union","E_NOT_IN_UNION","provided value is not in union",{provided:{type:f(r),value:r},expected:{type:"union",union:e}}),W=e=>{const r=null,u=null,v=null,y=e.map(o=>g(o)?o.literal:p(o)?`record(${JSON.stringify(Object.fromEntries(Object.entries(o.definition).map(([a,m])=>[a,m.schema])))})`:o.schema);return{schema:"union",I:r,O:u,E:v,validate:o=>e.map(c=>c.validate(o)).some(c=>c.status==="SUCCESS")?d(o):l(Q(y,o))}};n.array=j,n.arrayConstraint=w,n.boolean=R,n.date=U,n.dateConstraint=k,n.err=s,n.failure=l,n.fold=T,n.getDisplayType=f,n.isFailure=S,n.isLiteralSchema=g,n.isObject=h,n.isRecordSchema=p,n.isSuccess=A,n.literal=F,n.notAArray=I,n.notARecordError=b,n.nullable=K,n.number=Y,n.numberConstraint=$,n.objectKeys=E,n.optional=G,n.partial=z,n.record=_,n.string=P,n.stringConstraint=q,n.success=d,n.union=W,n.valueOf=N,Object.defineProperty(n,"__esModule",{value:!0}),n[Symbol.toStringTag]="Module"});
